icoll <- paste(db, "test", sep=".")
mongo.insert.batch(mongo2, icoll, list(a) )
dbs <- mongo.get.database.collections(mongo2, db)
print(dbs)
mongo.find.all(mongo2, icoll)
mongo2 <- mongo.create()
mongo2
mongo.is.connected(mongo2)
db="test_db"
icoll
print(dbs)
dbs
print(dbs)
mongo.find.all(mongo2, icoll)
mongo.insert.batch(mongo2, icoll, list(a) )
dbs <- mongo.get.database.collections(mongo2, db)
print(dbs)
mongo.find.all(mongo2, icoll)
mongo.get.database.collections(mongo2, db)
location
cars
list_from_frame<-data_frame
list_from_frame
list_from_frame<-as.list(data_frame)
list_from_frame<-as.list(data_frame)
list_from_frame
list_from_frame<-as.list(t(data_frame))
list_from_frame
?split
list_from_frame <- split(data_frame, rownames(data_frame))
list_from_frame
cars
as.data.frame(t(data_frame))
data_frame <- as.list(as.data.frame(t(data_frame)))
data_frame
list_from_frame <- split(data_frame, rownames(data_frame))
data_frame<-cars
data_frame
list_from_frame <- split(data_frame, rownames(data_frame))
list_from_frame
rownames(data_frame)
list_from_frame
list_from_frame[1]
names(list_from_frame)
order(names(list_from_frame))
?order
list_from_frame[order(names(list_from_frame))]
list_from_frame[order(names(list_from_frame))]
list_from_frame[order(names(list_from_frame)),]
list_from_frame[order(names(list_from_frame))]
list_from_frame[1:10]
list_from_frame[1:10]
list_from_frame[c(1,4,6)]
order(1,2,3)
order(c(1,2,3))
order(c(1,3,2))
as.numeric(names(list_from_frame))
order(as.numeric(names(list_from_frame)))
list_from_frame[order(as.numeric(names(list_from_frame)))]
list_from_frame<-list_from_frame[order(as.numeric(names(list_from_frame)))]
list_from_frame
mongo.bson.from.list()
?mongo.bson.from.list()
mongo.bson.from.list(list_from_frame)
bson_from_df<-mongo.bson.from.list(list_from_frame)
mongo.find.all(mongo,ns= table_name)
test
tables
db="datezer_development"
icoll <- paste(db, "test", sep=".")
icoll
db="datezer_development"
table_name <- paste(db, table_name, sep=".")
table_name
table_name<-"cars"
db="datezer_development"
table_name <- paste(db, table_name, sep=".")
mongo.insert.batch(mongo2, table_name, list(a) )
dbs <- mongo.get.database.collections(mongo2, db)
print(dbs)
mongo2, db
mongo2
mongo.get.database.collections(mongo2, db)
mongo2 <- mongo.create()
mongo2
mongo.is.connected(mongo2)
table_name<-"cars"
?split
db="dbname"
table_name <- paste(db, table_name, sep=".")
mongo.insert.batch(mongo2, table_name, list(a) )
dbs <- mongo.get.database.collections(mongo2, db)
print(dbs)
mongo.find.all(mongo2, icoll)
total_test
system(command="")
?system
mongo.drop(mongo2, icoll)
mongo2
mongo.find.all(mongo2, icoll)
dbs <- mongo.get.database.collections(mongo2, db)
print(dbs)
icoll
table_name_coll <- paste(db, table_name, sep=".")
mongo.find.all(mongo2, table_name_coll)
mongo.find.all(mongo2, table_name_coll)
table_name_coll
table_name_coll <- paste(db, table_name, sep=".")
table_name_coll
db
table_name="cars"
db="dbname"
table_name_coll <- paste(db, table_name, sep=".")
mongo.insert.batch(mongo2, table_name, list(a) )
table_name_coll
mongo.insert.batch(mongo2, table_name_coll, list(a) )
dbs <- mongo.get.database.collections(mongo2, db)
print(dbs)
mongo.find.all(mongo2, table_name_coll)
##############
#Delete stuff#
##############
mongo.drop(mongo2, table_name_coll)
#mongo.drop.database(mongo, db)
res <- mongo.get.database.collections(mongo2, db)
print(res)
tables<-mongo.get.database.collections(mongo, db = "datezer_development")
tables
list_from_frame
mongo.insert.batch(mongo2, table_name_coll, list_from_frame )
bson_from_df
data_frame_to_bson<-function(data_frame){
list_from_frame<-as.list(t(data_frame))
list_from_frame<- split(data_frame, rownames(data_frame))
list_from_frame<-list_from_frame[order(as.numeric(names(list_from_frame)))]
bson_from_df<-mongo.bson.from.list(list_from_frame)
}
table_name
db="datezer_development"
table_name_coll <- paste(db, table_name, sep=".")
mongo.insert.batch(mongo2, table_name_coll, data_frame_to_bson(data_frame) )
bson_from_df
mongo.find.all(mongo2, table_name_coll)
mongo.insert.batch(mongo2, table_name_coll, list(data_frame_to_bson(data_frame)) )
dbs <- mongo.get.database.collections(mongo2, db)
print(dbs)
mongo.find.all(mongo2, table_name_coll)
list_from_frame
bson_from_df
bson_from_df[1]
bson_from_df[[1]]
list_from_frame
?apply
list_bson_from_df<-apply(list_from_frame,MARGIN=1,mongo.bson.from.list)
list_from_frame
length(list_from_frame)
?lapply
list_bson_from_df<-lapply(list_from_frame,mongo.bson.from.list)
list_bson_from_df
list_from_frame
list_bson_from_df<-lapply(list_from_frame,mongo.bson.from.list)
mongo.insert.batch(mongo2, table_name_coll, list_bson_from_df)
dbs <- mongo.get.database.collections(mongo2, db)
print(dbs)
mongo.find.all(mongo2, table_name_coll)
table_name_coll
mongo.drop(mongo2, table_name_coll)
db="datezer_development"
table_name_coll <- paste(db, table_name, sep=".")
mongo.insert.batch(mongo2, table_name_coll, list_bson_from_df)
dbs <- mongo.get.database.collections(mongo2, db)
print(dbs)
mongo.find.all(mongo2, table_name_coll)
mongo.drop(mongo2, table_name_coll)
mongo.find.all(mongo2, table_name_coll)
db="datezer_development"
table_name_coll <- paste(db, table_name, sep=".")
mongo.insert.batch(mongo2, table_name_coll, list_bson_from_df)
dbs <- mongo.get.database.collections(mongo2, db)
print(dbs)
mongo.find.all(mongo2, table_name_coll)
table_name<-table_name_coll
table_name
test <- mongo.find.all(mongo,ns= table_name)#get mongo in list form
test
all_names<-NULL # get all names
for(i in 1:(length(test)-1)){
matches<-names(test[[i]])%in%names(test[[i+1]])
is_match_one<-"FALSE"%in%names(table(matches)) #are there all matches?
matches<-names(test[[i+1]])%in%names(test[[i]])
is_match_two<-"FALSE"%in%names(table(matches))
if(!(is_match_one&is_match_one)){
total_names<-unique(c(names(test[[i]]),names(test[[i+1]])))
all_names<-unique(c(total_names,all_names))
}
}
output<-data.frame(matrix(data=NA,nrow=length(test),ncol=length(all_names)))
names(output)<-all_names
for(i in 1:length(test)){
for(j in 1:length(test[[i]])){
index<-which(names(test[[i]][j])==all_names)
output[i,index]=test[[i]][[j]]
}
}
output
View(output)
setwd("~/Dropbox/Winter 2015/MV Research/MV-model/MvApp")
deployApp()
library(shinyapps)
install.packages(tseries)
install.packages("tseries")
install.packages("fOptions")
install.packages("lubridate")
deployApp()
deployApp()
shiny::runApp()
input_ticker
input_ticker<-c("aapl hsy")
tickers<-strsplit(input_ticker,split=" ")[[1]]
#set time series default
quote_1<-c("Open", "High", "Low", "Close", "AdjClose","Volume")
a1_raw = as.data.frame(get.hist.quote(instrument=tickers[1],start= start,end = end, quote = quote_1, compression = "m", retclass = "ts"))
a2_raw = as.data.frame(get.hist.quote(instrument=tickers[2],start= start,end = end, quote = quote_1, compression = "m", retclass = "ts"))
a1<-a1_raw[complete.cases(a1_raw),]
a2<-a2_raw[complete.cases(a2_raw),]
#Select only the close prices from each file:
prices <- as.data.frame(cbind(a1$Close, a2$Close))
#You can rename the Close prices as follows:
names(prices) <-c("p1", "p2")
#Convert the close prices into returns:
r1 <- (prices$p1[-length(prices$p1)]-prices$p1[-1])/prices$p1[-1]
r2 <- (prices$p2[-length(prices$p2)]-prices$p2[-1])/prices$p2[-1]
#Place the returns together in a data frame:
returns <- as.data.frame(cbind(r1,r2))
#total returns
total_returns <- paste(round(sapply(returns,sum)*100,digits=2),"%")
#Get summary statistics of the returns:
summary(returns)
#Get the variance covariance matrix of the returns:
cov(returns)
#Create many portfolios (combinations of the two stocks):
a <- seq(0,1,.01)
#Or simply
b <- 1-a
#Compute the expected return of each portfolio:
rp_bar <- a*mean(returns$r1)+b*mean(returns$r2)
#Compute the variance and standard deviation of each portfolio:
var_p <- a^2*var(returns$r1)+b^2*var(returns$r2)+2*a*b*cov(returns$r1,returns$r2)
sd_p <- var_p^.5
qq <- as.data.frame(cbind(sd_p, rp_bar))
main_frame<-data.frame(tickers,total_returns)
main_raw<-paste(tickers,"and")
main_1<-paste(main_raw[-length(main_raw)],tickers[length(main_raw)])
#If you want a line instead of points:
plot(qq, xlab="Portfolio risk (standard deviation)",
main=paste("Mean Variance Model for",main_1),
ylab="Expected return", type="l")
#get the minimum variance
x1 <- (var(returns$r2)-cov(returns$r1,returns$r2))/
plot(qq, xlab="Portfolio risk (standard deviation)",
main=paste("Mean Variance Model for",main_1),
ylab="Expected return", type="l")
#get the minimum variance
x1 <- (var(returns$r2)-cov(returns$r1,returns$r2))/
tickers
setProgress(detail = "Downloading Info")
tickers<-strsplit(input_ticker,split=" ")[[1]]
tickers
input_ticker
quote_1<-c("Open", "High", "Low", "Close", "AdjClose","Volume")
quote_1
a1_raw = as.data.frame(get.hist.quote(instrument=tickers[1],start= start,end = end, quote = quote_1, compression = "m", retclass = "ts"))
a2_raw = as.data.frame(get.hist.quote(instrument=tickers[2],start= start,end = end, quote = quote_1, compression = "m", retclass = "ts"))
a1<-a1_raw[complete.cases(a1_raw),]
a2<-a2_raw[complete.cases(a2_raw),]
#Select only the close prices from each file:
prices <- as.data.frame(cbind(a1$Close, a2$Close))
prices
names(prices) <-c("p1", "p2")
#Convert the close prices into returns:
r1 <- (prices$p1[-length(prices$p1)]-prices$p1[-1])/prices$p1[-1]
r2 <- (prices$p2[-length(prices$p2)]-prices$p2[-1])/prices$p2[-1]
r2
r1
r2
returns <- as.data.frame(cbind(r1,r2))
total_returns <- paste(round(sapply(returns,sum)*100,digits=2),"%")
total_returns
prices
prices$p1[-length(prices$p1)]
prices$p1[-1]
prices$p1[-length(prices$p1)]
prices$p1[-length(prices$p1)]
prices$p1[-1]
prices$p1[-length(prices$p1)]
prices$p1[-length(prices$p1)]
prices$p1[-1]
a1 <- read.table("http://www.stat.ucla.edu/~nchristo/statistics_c183_c283/
table_1.csv", header=TRUE, sep=",")
r1 <- (prices$p1[-1]-prices$p1[-length(prices$p1)])/prices$p1[-1]
r1
r2 <- (prices$p2[-1]-prices$p2[-length(prices$p2)])/prices$p2[-1]
#Place the returns together in a data frame:
returns <- as.data.frame(cbind(r1,r2))
#total returns
total_returns <- paste(round(sapply(returns,sum)*100,digits=2),"%")
#Get summary statistics of the returns:
summary(returns)
#Get the variance covariance matrix of the returns:
cov(returns)
#Create many portfolios (combinations of the two stocks):
a <- seq(0,1,.01)
#Or simply
b <- 1-a
#Compute the expected return of each portfolio:
rp_bar <- a*mean(returns$r1)+b*mean(returns$r2)
#Compute the variance and standard deviation of each portfolio:
var_p <- a^2*var(returns$r1)+b^2*var(returns$r2)+2*a*b*cov(returns$r1,returns$r2)
sd_p <- var_p^.5
qq <- as.data.frame(cbind(sd_p, rp_bar))
main_frame<-data.frame(tickers,total_returns)
main_raw<-paste(tickers,"and")
main_1<-paste(main_raw[-length(main_raw)],tickers[length(main_raw)])
#If you want a line instead of points:
plot(qq, xlab="Portfolio risk (standard deviation)",
main=paste("Mean Variance Model for",main_1),
ylab="Expected return", type="l")
#get the minimum variance
x1 <- (var(returns$r2)-cov(returns$r1,returns$r2))/
(var(returns$r1)+var(returns$r2)-2*cov(returns$r1,returns$r2))
x2 <- 1-x1
rp_bar_min <- x1*mean(returns$r1)+x2*mean(returns$r2)
sd_p_min <- (x1^2*var(returns$r1)+x2^2*var(returns$r2)+
2*x1*x2*cov(returns$r1,returns$r2))^0.5
qqq <- qq[qq$rp_bar > rp_bar_min,]
setProgress(detail = "Plotting")
#And then draw the efficient frontier:
points(qqq, col="blue", type="l", lwd=5)
legend("bottomright",legend = "efficiency frontier",col="blue",lty=1,lwd=5)
legend_frame<-data.frame(tickers,total_returns)
legend_2<-paste(tickers,"total return:",total_returns)
legend("topleft",legend = legend_2,col=rainbow(length(legend_2)))
}
plot(qq, xlab="Portfolio risk (standard deviation)",
main=paste("Mean Variance Model for",main_1),
ylab="Expected return", type="l")
#get the minimum variance
x1 <- (var(returns$r2)-cov(returns$r1,returns$r2))/
(var(returns$r1)+var(returns$r2)-2*cov(returns$r1,returns$r2))
x2 <- 1-x1
rp_bar_min <- x1*mean(returns$r1)+x2*mean(returns$r2)
sd_p_min <- (x1^2*var(returns$r1)+x2^2*var(returns$r2)+
2*x1*x2*cov(returns$r1,returns$r2))^0.5
qqq <- qq[qq$rp_bar > rp_bar_min,]
setProgress(detail = "Plotting")
#And then draw the efficient frontier:
points(qqq, col="blue", type="l", lwd=5)
legend("bottomright",legend = "efficiency frontier",col="blue",lty=1,lwd=5)
legend_frame<-data.frame(tickers,total_returns)
legend_2<-paste(tickers,"total return:",total_returns)
legend("topleft",legend = legend_2,col=rainbow(length(legend_2)))
shiny::runApp()
input_ticker<-"aapl ma"
tickers<-strsplit(input_ticker,split=" ")[[1]]
#set time series default
quote_1<-c("Open", "High", "Low", "Close", "AdjClose","Volume")
a1_raw = as.data.frame(get.hist.quote(instrument=tickers[1],start= start,end = end, quote = quote_1, compression = "m", retclass = "ts"))
a2_raw = as.data.frame(get.hist.quote(instrument=tickers[2],start= start,end = end, quote = quote_1, compression = "m", retclass = "ts"))
tickers
shiny::runApp()
shiny::runApp()
deployApp()
shiny::runApp()
total_returns <- paste(round(sapply(returns,sum)*100,digits=2),"%")
total_returns
?sleep
?sys.sleep
?system.sleep
setProgress(detail = "Downloading Info")
Sys.sleep(1)
shiny::runApp()
shiny::runApp()
head(returns)
head(r1)
head(r1,3)
shiny::runApp()
deployApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
a1
head(a1,1)
quote_1<-"Close"
a1_raw = as.data.frame(get.hist.quote(instrument=tickers[1],start= start,end = end, quote = quote_1, compression = "m", retclass = "ts"))
a2_raw = as.data.frame(get.hist.quote(instrument=tickers[2],start= start,end = end, quote = quote_1, compression = "m", retclass = "ts"))
a1<-a1_raw[complete.cases(a1_raw),]
a2<-a2_raw[complete.cases(a2_raw),]
#Select only the close prices from each file:
prices <- as.data.frame(cbind(a1$Close, a2$Close))
a1
a1
a1_raw
shiny::runApp()
data.frame(a1,a2)
prices <- data.frame(a1,a2)
shiny::runApp()
setwd("~/Dropbox/Winter 2015/MV Research/MV-model/MvApp")
deployApp()
start
start_date
start_date=start
end_date=end
#Libraries
library(tseries)
library(fOptions)
library(lubridate)
###########
#Variables#
###########
#ticker<-"aapl hsy"
#start<-as.Date("2010/01/01", "%Y/%m/%d")
#end<-as.Date("2014/01/01", "%Y/%m/%d")
#tickers=c("aapl","hsy")
##########
#BASIC MV#
##########
get_mv_graph<-function(input_ticker,start_date_raw,end_date_raw){
tickers<-strsplit(input_ticker,split=" ")[[1]]
start_date<-as.Date(start_date_raw, "%Y/%m/%d")
end_date<-as.Date(end_date_raw, "%Y/%m/%d")
#set time series default
#quote_1<-c("Open", "High", "Low", "Close", "AdjClose","Volume")
quote_1<-"Close"
a1_raw = as.data.frame(get.hist.quote(instrument=tickers[1],start= start_date,end = end_date, quote = quote_1, compression = "m", retclass = "ts"))
a2_raw = as.data.frame(get.hist.quote(instrument=tickers[2],start= start_date,end = end_date, quote = quote_1, compression = "m", retclass = "ts"))
a1<-a1_raw[complete.cases(a1_raw),]
a2<-a2_raw[complete.cases(a2_raw),]
#Select only the close prices from each file:
prices <- data.frame(a1,a2)
#You can rename the Close prices as follows:
names(prices) <-c("p1", "p2")
#Convert the close prices into returns:
r1 <- (prices$p1[-1]-prices$p1[-length(prices$p1)])/prices$p1[-1]
r2 <- (prices$p2[-1]-prices$p2[-length(prices$p2)])/prices$p2[-1]
#Place the returns together in a data frame:
returns <- as.data.frame(cbind(r1,r2))
#total returns
total_returns <- paste(round(sapply(returns,sum)*100,digits=2),"%")
setProgress(detail = input_ticker)
Sys.sleep(3)
setProgress(detail = head(a1,3))
Sys.sleep(3)
setProgress(detail = head(r1,3))
Sys.sleep(3)
setProgress(detail = total_returns)
Sys.sleep(3)
setProgress(detail = total_returns)
#Get summary statistics of the returns:
summary(returns)
#Get the variance covariance matrix of the returns:
cov(returns)
#Create many portfolios (combinations of the two stocks):
a <- seq(0,1,.01)
#Or simply
b <- 1-a
#Compute the expected return of each portfolio:
rp_bar <- a*mean(returns$r1)+b*mean(returns$r2)
#Compute the variance and standard deviation of each portfolio:
var_p <- a^2*var(returns$r1)+b^2*var(returns$r2)+2*a*b*cov(returns$r1,returns$r2)
sd_p <- var_p^.5
qq <- as.data.frame(cbind(sd_p, rp_bar))
main_frame<-data.frame(tickers,total_returns)
main_raw<-paste(tickers,"and")
main_1<-paste(main_raw[-length(main_raw)],tickers[length(main_raw)])
#If you want a line instead of points:
plot(qq, xlab="Portfolio risk (standard deviation)",
main=paste("Mean Variance Model for",main_1),
ylab="Expected return", type="l")
#get the minimum variance
x1 <- (var(returns$r2)-cov(returns$r1,returns$r2))/
(var(returns$r1)+var(returns$r2)-2*cov(returns$r1,returns$r2))
x2 <- 1-x1
rp_bar_min <- x1*mean(returns$r1)+x2*mean(returns$r2)
sd_p_min <- (x1^2*var(returns$r1)+x2^2*var(returns$r2)+
2*x1*x2*cov(returns$r1,returns$r2))^0.5
qqq <- qq[qq$rp_bar > rp_bar_min,]
setProgress(detail = "Plotting")
#And then draw the efficient frontier:
points(qqq, col="blue", type="l", lwd=5)
legend("bottomright",legend = "efficiency frontier",col="blue",lty=1,lwd=5)
legend_frame<-data.frame(tickers,total_returns)
legend_2<-paste(tickers,"total return:",total_returns)
legend("topleft",legend = legend_2,col=rainbow(length(legend_2)))
}
get_mv_graph(input$ticker,input$start_date,input$end_date)
get_mv_graph(tickers,start_date,end_date)
ticker
tickers
get_mv_graph(tickers,start_date,end_date)
tickers<-strsplit(input_ticker,split=" ")[[1]]
tickers
input_ticker=tickers
tickers
input_ticker<-"aapl hsy"
get_mv_graph(input_ticker,start_date,end_date)
shiny::runApp()
shiny::runApp()
start_date_raw
shiny::runApp()
shiny::runApp()
deployApp(0)
deployApp()
