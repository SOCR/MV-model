#  (1) the 'rotor.start' position, which is three letter combination, for
#    example "ERT", "PWQ", or "TMM",
#  (2) the 'ring' setting, which is also a three letter combination,
#  (3) the 'rotor.config', three of the eight Enigma machine rotors in order
#    from left to right, supplied as a numeric vector, for example c(1,2,3),
#    c(6,4,3), or c(8,1,2),
#  (4) the 'reflector', of which there existed two variants, called "B" and
#    "C", default is "B".
#  (5) the 'plugboard' settings, a list of letter pairs to be cross-coupled,
#    list(c("A","B")) and list(c("B","A")) will yield the same result; note
#    that any one letter cannot be cross-coupled to more than one other
#    letter. Character vector, e.g. c("AB","CD"), will be converted to list.
# Note that the Enigma machine was delivered with only one rotor of each, so
# in practice rotor orders such as c(1,1,1) or c(4,2,2) could not be used.
# However, this emulator does not have that restriction.
# Note also that no letter can be encrypted into itself, which allowed for
# quick so-called 'crib dragging', which sped up brute force attacks greatly.
# A crib is a snippet of text presumed to be included in the decrypted
# message, for example "WEATHERREPORT". Another weakness of the Enigma
# machine is the ordered one-to-one correspondence between letters in the
# encrypted and decrypted messages; if one letter is changed in the decrypted
# message, it will only affect the one letter in the same position of the
# encrypted message.
m <- function(x){ ((x-1) %% 26) +1 }
if(is.character(plugboard)){ plugboard <- strsplit(plugboard,split="")}
if(length(plugboard) > 0){
plug.check <- character(0)
for(i in 1:length(plugboard)){
if(length(plugboard[[i]]) != 2){
stop("plugboard list must contain pairs of characters")
}
plugboard[[i]] <- toupper(plugboard[[i]])
if(any(plug.check == plugboard[[i]][1]) | any(plug.check == plugboard[[i]][2])){
stop("plugboard has duplicate letters")
}
plug.check <- c(plug.check,plugboard[[i]])
}
}
pb <- function(x){
if(length(plugboard) > 0){
for(i in 1:length(plugboard)){
if(any(plugboard[[i]] == x)){
return(plugboard[[i]][-which(plugboard[[i]] == x)[1]])
}
}
}
return(x)
}
alph <- unlist(strsplit(rawToChar(as.raw(65:90)),split = ""))
ring.pos <- which(alph == unlist(strsplit(toupper(ring), split = ""))[1])-1
ring.pos[2] <- which(alph == unlist(strsplit(toupper(ring), split = ""))[2])-1
ring.pos[3] <- which(alph == unlist(strsplit(toupper(ring), split = ""))[3])-1
if(toupper(reflector) == "B"){refl.num <- 11}
if(toupper(reflector) == "C"){refl.num <- 12}
rotor.data <- list(I = rbind(alph,unlist(strsplit("EKMFLGDQVZNTOWYHXUSPAIBRCJ",split = ""))),
II = rbind(alph,unlist(strsplit("AJDKSIRUXBLHWTMCQGZNPYFVOE",split = ""))),
III = rbind(alph,unlist(strsplit("BDFHJLCPRTXVZNYEIWGAKMUSQO",split = ""))),
IV = rbind(alph,unlist(strsplit("ESOVPZJAYQUIRHXLNFTGKDCMWB",split = ""))),
V = rbind(alph,unlist(strsplit("VZBRGITYUPSDNHLXAWMJQOFECK",split = ""))),
VI = rbind(alph,unlist(strsplit("JPGVOUMFYQBENHZRDKASXLICTW",split = ""))),
VII = rbind(alph,unlist(strsplit("NZJHGRCXMYSWBOUFAIVLPEKQDT",split = ""))),
VIII = rbind(alph,unlist(strsplit("FKQHTLXOCBJSPDZRAMEWNIUYGV",split = ""))),
Beta = rbind(alph,unlist(strsplit("LEYJVCNIXWPBQMDRTAKZGFUHOS",split = ""))),
Gamma = rbind(alph,unlist(strsplit("FSOKANUERHMBTIYCWLQPZXVGJD",split = ""))),
reflectorB = rbind(alph,unlist(strsplit("YRUHQSLDPXNGOKMIEBFZCWVJAT",split = ""))),
reflectorC = rbind(alph,unlist(strsplit("FVPJIAOYEDRZXWGCTKUQSBNMHL",split = ""))))
turnover.data <- list(I=16, II=4, III=21, IV=9, V=25, VI=c(12,25), VII=c(12,25), VIII=c(12,25))
rotors <- list(rotor1 = rotor.data[[rotor.config[1]]],
rotor2 = rotor.data[[rotor.config[2]]],
rotor3 = rotor.data[[rotor.config[3]]],
reflector = rotor.data[[refl.num]])
turns <- c(turnover.data[rotor.config[1]],turnover.data[rotor.config[2]],turnover.data[rotor.config[3]])
rotor.pos <- (which(alph == unlist(strsplit(toupper(rotor.start), split = ""))[1])-1-ring.pos[1])%% 26
rotor.pos[2] <- (which(alph == unlist(strsplit(toupper(rotor.start), split = ""))[2])-1-ring.pos[2])%% 26
rotor.pos[3] <- (which(alph == unlist(strsplit(toupper(rotor.start), split = ""))[3])-1-ring.pos[3])%% 26
in_tmp <- toupper(input)
in_tmp <- gsub(" ","",in_tmp)
in_tmp <- gsub("[[:punct:]]", "", in_tmp)
in_tmp <- unlist(strsplit(in_tmp, split = ""))
out <- character(0)
while(length(in_tmp) > 0){
if(any((rotor.pos[2]+ring.pos[2])%%26 == turns[[2]])){
rotor.pos[1] <- m(rotor.pos[1]+1)
rotor.pos[2] <- m(rotor.pos[2]+1)
}
if(any((rotor.pos[3]+ring.pos[3])%%26 == turns[[3]]) & all((rotor.pos[2]+ring.pos[2])%%26 != turns[[2]])){
rotor.pos[2] <- m(rotor.pos[2]+1)
}
rotor.pos[3] <- m(rotor.pos[3]+1)
a <- pb(in_tmp[1])
a <- rotors$rotor3[2,m(which(alph == a)+rotor.pos[3])]
a <- rotors$rotor2[2,m(which(rotors$rotor3[1,] == a)-rotor.pos[3]+rotor.pos[2])]
a <- rotors$rotor1[2,m(which(rotors$rotor2[1,] == a)-rotor.pos[2]+rotor.pos[1])]
a <- rotors$reflector[2,m(which(rotors$rotor1[1,] == a)-rotor.pos[1])]
a <- rotors$rotor1[1,m(which(rotors$reflector[1,] == a)+rotor.pos[1])]
a <- rotors$rotor2[1,m(which(rotors$rotor1[2,] == a)-rotor.pos[1]+rotor.pos[2])]
a <- rotors$rotor3[1,m(which(rotors$rotor2[2,] == a)-rotor.pos[2]+rotor.pos[3])]
a <- pb(alph[m(which(rotors$rotor3[2,] == a)-rotor.pos[3])])
out <- c(out,a)
in_tmp <- in_tmp[-1]
}
return(paste(out,collapse = ""))
}
next_key <- function(x){
# Utility function useful for the Enigma emulator. Function accepts a
# three letter character string or vector, e.g. 'AAA', and returns the
# next three letter character string in lexicographical order. For
# example, 'AAA' become 'AAB', and 'DZZ' becomes 'EAA'.
#   Note that this function does not replicate the rotor steppings of
# the Enigma machine, which depend on the rotor configuration used.
tmp <- unlist(strsplit(toupper(x),split = ""))
alph <- unlist(strsplit(rawToChar(as.raw(65:90)),split = ""))
tmp_v <- c(which(alph == tmp[1]),which(alph == tmp[2]),which(alph == tmp[3]))
tmp_v[3] <- tmp_v[3]+1
if(tmp_v[3] == 27){ tmp_v[2] <- tmp_v[2]+1; tmp_v[3] <- 1}
if(tmp_v[2] == 27){ tmp_v[1] <- tmp_v[1]+1; tmp_v[2] <- 1}
if(tmp_v[1] == 27){ tmp_v <- c(1,1,1)}
return(paste(alph[tmp_v],collapse = ""))
}
correct_rotor<-break_code(code_piece,guess,"AAA")
break_code<-function(code_piece,guess,key){
while(Enigma(code_piece, rotor.start = key) != guess)
{
key<-next_key(key)
}
solution<-key
return(key)
}
get_correct_ring<-function(code_original,code_piece,ring_start){
default<-ring_start
#remove Spaces
code_original<-gsub(" ","",code_original)
code_piece<-gsub(" ","",code_piece)
#get length to turn back
turnback<-nchar(code_original)- nchar(code_piece)
#turn back n times
for(i in 1 : turnback){
default<-next_key(default)
}
return(default)
}
Enigma(code_piece, rotor.start = correct_rotor_original, ring =ring_start )
correct_rotor<-break_code(code_piece,guess,"AAA")
#Set Ring Start Default
ring_start<-"AAA"
#Get Correct Ring
correct_ring<-get_correct_ring(code_original,code_piece,rotor_start)
get_correct_ring<-function(code_original,code_piece,ring_start){
default<-ring_start
#remove Spaces
code_original<-gsub(" ","",code_original)
code_piece<-gsub(" ","",code_piece)
#get length to turn back
turnback<-nchar(code_original)- nchar(code_piece)
#turn back n times
for(i in 1 : turnback){
default<-next_key(default)
}
return(default)
}
correct_ring<-get_correct_ring(code_original,code_piece,rotor_start)
#Generate FULL MESSAGE
correct_ring<-get_correct_ring(code_original,code_piece,ring_start)
#Generate FULL MESSAGE
Enigma(code_piece, rotor.start = correct_rotor_original, ring =ring_start )
Enigma("PCYXTZQK", rotor.start = "TZH")
Enigma(code_original, rotor.start = correct_rotor, ring = correct_ring ,rotor.config = c(1,2,3), reflector = "B")
correct_rotor<-"UJQ"
ring_start<-"AAK"
code_piece <- "KRK"
guess<-"ANX"
correct_ring<-get_correct_ring(code_original,code_piece,ring_start)
Enigma(code_piece, rotor.start = correct_rotor, ring =ring_start )
Enigma(code_original, rotor.start = correct_rotor, ring = correct_ring)
code_original <- "KRKW PXMB NFZV FGGJ XJIX DODQ CWLL LXZP KSRP OJQQ DNEP RXXHv CSCM GIOB KYAS WDCY RLYB GNAZ HSCG FSEQ YTWV XMQW YACJ LSNR
correct_ring<-get_correct_ring(code_original,code_piece,ring_start)
Enigma(code_piece, rotor.start = correct_rotor, ring =ring_start )
Enigma(code_original, rotor.start = correct_rotor, ring = correct_ring)
code_original <- "KRKW PXMB NFZV FGGJ XJIX DODQ CWLL LXZP KSRP OJQQ DNEP RXXHv CSCM GIOB KYAS WDCY RLYB GNAZ HSCG FSEQ YTWV XMQW YACJ LSNR
FAAM DCAD LUSY OUTP WE"
code_original <- "KRKW PXMB NFZV FGGJ XJIX DODQ CWLL LXZP KSRP OJQQ DNEP RXXHv CSCM GIOB KYAS WDCY RLYB GNAZ HSCG FSEQ YTWV XMQW YACJ LSNR
FAAM DCAD LUSY OUTP WE"
correct_ring<-get_correct_ring(code_original,code_piece,ring_start)
Enigma(code_piece, rotor.start = correct_rotor, ring =ring_start )
Enigma(code_original, rotor.start = correct_rotor, ring = correct_ring)
code_piece2 <- "LUSYOUTPWE"
guess2<-"YOURSTRULY"
correct_ring<-get_correct_ring(code_original,code_piece2,ring_start)
Enigma(code_piece2, rotor.start = correct_rotor, ring =ring_start )
Enigma(code_original, rotor.start = correct_rotor, ring = correct_ring)
break_code_two<-function(code_piece,guess){
ring<-"AAA"
solution<-data.frame(1,1)
i=1
#iterate through all possibilities of rings
while(ring!="ZZZ")
{
key<-"AAA"
while(key!="ZZZ")
{
ENIGMA<-Enigma(code_piece, rotor.start = key, ring=ring)
if(ENIGMA == guess){
solution[i,1]<-key
solution[i,2]<-ring
solution[i,1]<<-key
solution[i,2]<<-ring
i=i+1
#break
}
key<-next_key(key)
}
#if(ENIGMA == guess){
#break
#}
print(paste(key,ring))
ring<-next_key(ring)
}
return(solution)
}
a<-break_code_two(code_piece2,guess2)
flights<-read.csv(url("http://www.stat.ucla.edu/~vlew/datasets/flights.csv"),stringsAsFactors=FALSE)
individuals<-read.csv(url("http://www.stat.ucla.edu/~vlew/datasets/individuals.csv "))
florida<-readLines(url("http://www.stat.ucla.edu/~vlew/datasets/florida2000.dat"))
florida<-as.character(florida[-1])
florida<-read.table(text=florida,sep=" ",header=TRUE)
FRB<-read.csv(url("http://www.stat.ucla.edu/~vlew/datasets/FRB_H10.csv"),header=TRUE,stringsAsFactors=FALSE)
#Part 1
names(flights)<-tolower(names(flights))
flights<-flights[complete.cases(flights),]
dep_delay<-flights$dep_delay
routes<-flights$routes
boxplot(dep_delay~routes,col=rainbow(10),main="Flight Departure Delays by Route",ylab="minutes",xlab="Routes")
names(florida)<-tolower(names(florida))
plot(florida$bush,florida$buchanan,col="blue",pch=16,xlab="Votes for Bush",ylab="Votes for Buchanan",main="Florida 2000")
lineOne<-lm(buchanan~bush,data=florida)
abline(lineOne,col="red",lwd=3)
text(florida$bush, florida$buchanan, labels=florida$county, cex= 0.7)
#Part 4
library(lubridate)
names(FRB)<-tolower(names(FRB))
head(FRB)
plot(range(as.Date(FRB$time.period)), range(c(FRB$jrxwtfb_n.m,FRB$jrxwtfn_n.m)), type="n", xlab="Year",ylab="Index",main="Foreign Exchange Rate" )
lines(as.Date(FRB$time.period),FRB$jrxwtfb_n.m,lty=1,lwd=2,col="blue")
lines(as.Date(FRB$time.period),FRB$jrxwtfn_n.m,lty=1,lwd=2,col="red")
legend(x="bottomright",legend=c("JRXWTFB_N.M","JRXWTFN_N.M"),title="Series",col=c("blue","red"),lwd=2)
names(individuals)<-tolower(names(individuals))
individuals<-individuals[complete.cases(individuals),]
par(mfrow=c(2,1))
stature_female<-individuals$stature[individuals$sex==1&individuals$stature!=0]
stature_male<-individuals$stature[individuals$sex==2&individuals$stature!=0]
hist(stature_female,col="red",ylab="density",xlab="height",main="Histogram of Stature â Females")
hist(stature_male,col="blue",ylab="density",xlab="height",main="Histogram of Stature â Males")
a<c(5.3299,4.2537,3.1502,1.6070,3.1181,6.5841,3.5281,4.7433,.1077,1.5977,5.4920,1.7220,4.1547,2.2799)
a
a<-c(5.3299,4.2537,3.1502,1.6070,3.1181,6.5841,3.5281,4.7433,.1077,1.5977,5.4920,1.7220,4.1547,2.2799)
a
meam(a)
mean(a)
a<-c(5.3299,4.2537,3.1502,3.7032,1.6070,3.1181,6.5841,3.5281,4.7433,.1077,1.5977,5.4920,1.7220,4.1547,2.2799)
a
mean(a)
a<-c(5.3299,4.2537,3.1502,3.7032,1.6070,6.3923,3.1181,6.5941,3.5281,4.7433,.1077,1.5977,5.4920,1.7220,4.1547,2.2799)
a
mean(a)
var(a)
count(a)
dim(a)
names(a)
a
sum(a)
b<-a-mean(a)
b
c<-b^2
sum(c)
55^2
3025/16
c/16
sum(c)/16
sqrt(3.2044)
2.131*3.41
1.753*3.4
8.102/1.753
1.848/sqrt(16)
3.41/4
*2.131
.8525*3.41/4
3.41/4
1.848/4
.462*2.131
1.848^2
15*3.14
15*3.41
51.15/7.26
14*255.56^2/150^2
16.*1.6
1.6*1.6
8000-250^2
250^2
8000/15
250/15
533.33-16.666^2
6.57+23.68
30.25/2
.4266/sqrt(15)
.2/.1101
-.15*sqrt(15)/.4266
+1.64
1.64-1.361808
1.761*4.266
7.512^2
a1 <- read.table("http://www.stat.ucla.edu/~nchristo/statistics_c183_c283/
table_1.csv", header=TRUE, sep=",")
a2 <- read.table("http://www.stat.ucla.edu/~nchristo/statistics_c183_c283/
table_2.csv", header=TRUE, sep=",")
##########
#BASIC MV#
##########
#Select only the close prices from each file:
prices <- as.data.frame(cbind(a1$Close, a2$Close))
#You can rename the Close prices as follows:
names(prices) <-c("p1", "p2")
#Convert the close prices into returns:
r1 <- (prices$p1[-length(prices$p1)]-prices$p1[-1])/prices$p1[-1]
r2 <- (prices$p2[-length(prices$p2)]-prices$p2[-1])/prices$p2[-1]
#Place the returns together in a data frame:
returns <- as.data.frame(cbind(r1,r2))
#Get summary statistics of the returns:
summary(returns)
#Get the variance covariance matrix of the returns:
cov(returns)
#Create many portfolios (combinations of the two stocks):
a <- seq(0,1,.01)
b <- seq(1,0,-.01)
#Or simply
b <- 1-a
#Compute the expected return of each portfolio:
rp_bar <- a*mean(returns$r1)+b*mean(returns$r2)
#Compute the variance and standard deviation of each portfolio:
var_p <- a^2*var(returns$r1)+b^2*var(returns$r2)+
2*a*b*cov(returns$r1,returns$r2)
sd_p <- var_p^.5
qq <- as.data.frame(cbind(sd_p, rp_bar))
#If you want a line instead of points:
plot(qq, xlab="Portfolio risk (standard deviation)",
ylab="Expected return", type="l")
#get the minimum variance
x1 <- (var(returns$r2)-cov(returns$r1,returns$r2))/
(var(returns$r1)+var(returns$r2)-2*cov(returns$r1,returns$r2))
x2 <- 1-x1
rp_bar_min <- x1*mean(returns$r1)+x2*mean(returns$r2)
sd_p_min <- (x1^2*var(returns$r1)+x2^2*var(returns$r2)+
2*x1*x2*cov(returns$r1,returns$r2))^0.5
qqq <- qq[qq$rp_bar > rp_bar_min,]
#And then draw the efficient frontier:
points(qqq, col="blue", type="l", lwd=5)
##########
#Gao Test#
##########
predict_n_steps_ahead=3
freq_skip=1
start<-as.Date("2000/01/03", "%Y/%m/%d")
end<-as.Date("2008/12/01", "%Y/%m/%d")
start_backtest<-as.Date("2002/02/02", "%Y/%m/%d")
risk=.2
ts_frequency<-12
a1<-ts(prices[1],start=decimal_date(start),frequency=12)
a<-ts(prices[1],start=decimal_date(start),frequency=12)
prices[1]
parameters<-list(start_backtest=start_backtest,predict_n_steps_ahead=predict_n_steps_ahead,start=start,end=end,ticker=ticker)
points<-backtestPoints(a1,start_backtest,predict_n_steps_ahead,freq_skip,parameters,ts_frequency=12)
prices <- as.data.frame(cbind(a1$Close, a2$Close))
a1 <- read.table("http://www.stat.ucla.edu/~nchristo/statistics_c183_c283/
table_1.csv", header=TRUE, sep=",")
a2 <- read.table("http://www.stat.ucla.edu/~nchristo/statistics_c183_c283/
table_2.csv", header=TRUE, sep=",")
a1 <- read.table("http://www.stat.ucla.edu/~nchristo/statistics_c183_c283/
table_1.csv", header=TRUE, sep=",")
a2 <- read.table("http://www.stat.ucla.edu/~nchristo/statistics_c183_c283/
table_2.csv", header=TRUE, sep=",")
a1 <- read.table("http://www.stat.ucla.edu/~nchristo/statistics_c183_c283/
table_1.csv", header=TRUE, sep=",")
a2 <- read.table("http://www.stat.ucla.edu/~nchristo/statistics_c183_c283/
table_2.csv", header=TRUE, sep=",")
a1 <- read.table("http://www.stat.ucla.edu/~nchristo/statistics_c183_c283/
table_1.csv", header=TRUE, sep=",")
prices <- as.data.frame(cbind(a1$Close, a2$Close))
#You can rename the Close prices as follows:
names(prices) <-c("p1", "p2")
#Convert the close prices into returns:
r1 <- (prices$p1[-length(prices$p1)]-prices$p1[-1])/prices$p1[-1]
r2 <- (prices$p2[-length(prices$p2)]-prices$p2[-1])/prices$p2[-1]
#Place the returns together in a data frame:
returns <- as.data.frame(cbind(r1,r2))
#Get summary statistics of the returns:
summary(returns)
#Get the variance covariance matrix of the returns:
cov(returns)
a <- seq(0,1,.01)
b <- seq(1,0,-.01)
#Or simply
#Compute the expected return of each portfolio:
rp_bar <- a*mean(returns$r1)+b*mean(returns$r2)
#Compute the variance and standard deviation of each portfolio:
2*a*b*cov(returns$r1,returns$r2)
sd_p <- var_p^.5
var_p <- a^2*var(returns$r1)+b^2*var(returns$r2)+
b <- 1-a
#Create many portfolios (combinations of the two stocks):
qq <- as.data.frame(cbind(sd_p, rp_bar))
#If you want a line instead of points:
plot(qq, xlab="Portfolio risk (standard deviation)",
ylab="Expected return", type="l")
prices <- as.data.frame(cbind(a1$Close, a2$Close))
#You can rename the Close prices as follows:
names(prices) <-c("p1", "p2")
#Convert the close prices into returns:
r1 <- (prices$p1[-length(prices$p1)]-prices$p1[-1])/prices$p1[-1]
r2 <- (prices$p2[-length(prices$p2)]-prices$p2[-1])/prices$p2[-1]
#Place the returns together in a data frame:
returns <- as.data.frame(cbind(r1,r2))
#Get summary statistics of the returns:
summary(returns)
#Get the variance covariance matrix of the returns:
cov(returns)
#Create many portfolios (combinations of the two stocks):
a <- seq(0,1,.01)
b <- seq(1,0,-.01)
#Or simply
b <- 1-a
#Compute the expected return of each portfolio:
rp_bar <- a*mean(returns$r1)+b*mean(returns$r2)
#Compute the variance and standard deviation of each portfolio:
var_p <- a^2*var(returns$r1)+b^2*var(returns$r2)+
2*a*b*cov(returns$r1,returns$r2)
sd_p <- var_p^.5
qq <- as.data.frame(cbind(sd_p, rp_bar))
#If you want a line instead of points:
plot(qq, xlab="Portfolio risk (standard deviation)",
ylab="Expected return", type="l")
#get the minimum variance
x1 <- (var(returns$r2)-cov(returns$r1,returns$r2))/
(var(returns$r1)+var(returns$r2)-2*cov(returns$r1,returns$r2))
x2 <- 1-x1
rp_bar_min <- x1*mean(returns$r1)+x2*mean(returns$r2)
sd_p_min <- (x1^2*var(returns$r1)+x2^2*var(returns$r2)+
2*x1*x2*cov(returns$r1,returns$r2))^0.5
qqq <- qq[qq$rp_bar > rp_bar_min,]
#And then draw the efficient frontier:
points(qqq, col="blue", type="l", lwd=5)
plot(qq, xlab="Portfolio risk (standard deviation)",
ylab="Expected return", type="l")
#get the minimum variance
plot(qq, xlab="Portfolio risk (standard deviation)",
ylab="Expected return", type="l")
plot(qq, xlab="Portfolio risk (standard deviation)",main="Mean Variance Model"
ylab="Expected return", type="l")
?legend()
?legend("bottomright",legend = "efficiency frontier")
legend("bottomright",legend = "efficiency frontier")
legend("topright",legend = "efficiency frontier")
legend("topright",legend = "efficiency frontier",col="blue")
legend("topright",legend = "efficiency frontier",col="blue",lty=1)
legend("topright",legend = "efficiency frontier",col="blue",lty=4)
legend("topright",legend = "efficiency frontier",col="blue",lty=1,lwd=2)
legend("topright",legend = "efficiency frontier",col="blue",lty=1,lwd=5)
#get the minimum variance
x1 <- (var(returns$r2)-cov(returns$r1,returns$r2))/
(var(returns$r1)+var(returns$r2)-2*cov(returns$r1,returns$r2))
x2 <- 1-x1
rp_bar_min <- x1*mean(returns$r1)+x2*mean(returns$r2)
sd_p_min <- (x1^2*var(returns$r1)+x2^2*var(returns$r2)+
2*x1*x2*cov(returns$r1,returns$r2))^0.5
qqq <- qq[qq$rp_bar > rp_bar_min,]
#And then draw the efficient frontier:
points(qqq, col="blue", type="l", lwd=5)
plot(qq, xlab="Portfolio risk (standard deviation)",main="Mean Variance Model"
ylab="Expected return", type="l")
plot(qq, xlab="Portfolio risk (standard deviation)",main="Mean Variance Model"
ylab="Expected return", type="l")
plot(qq, xlab="Portfolio risk (standard deviation)",main="Mean Variance Model",
ylab="Expected return", type="l")
legend("topright",legend = "efficiency frontier",col="blue",lty=1,lwd=5)
#get the minimum variance
x1 <- (var(returns$r2)-cov(returns$r1,returns$r2))/
(var(returns$r1)+var(returns$r2)-2*cov(returns$r1,returns$r2))
x2 <- 1-x1
rp_bar_min <- x1*mean(returns$r1)+x2*mean(returns$r2)
sd_p_min <- (x1^2*var(returns$r1)+x2^2*var(returns$r2)+
2*x1*x2*cov(returns$r1,returns$r2))^0.5
qqq <- qq[qq$rp_bar > rp_bar_min,]
#And then draw the efficient frontier:
points(qqq, col="blue", type="l", lwd=5)
shiny::runApp('C:/Users/Alizee/Dropbox/Winter 2015/MV Research/MvApp')
shiny::runApp('C:/Users/Alizee/Dropbox/Winter 2015/MV Research/MvApp')
shiny::runApp('C:/Users/Alizee/Dropbox/Winter 2015/MV Research/MvApp')
shiny::runApp('C:/Users/Alizee/Dropbox/Winter 2015/MV Research/MvApp')
shiny::runApp('C:/Users/Alizee/Dropbox/Winter 2015/MV Research/MvApp')
shiny::runApp('C:/Users/Alizee/Dropbox/Winter 2015/MV Research/MvApp')
shiny::runApp('C:/Users/Alizee/Dropbox/Winter 2015/MV Research/MvApp')
?tabPanel
shiny::runApp('C:/Users/Alizee/Dropbox/Winter 2015/MV Research/MvApp')
shiny::runApp('C:/Users/Alizee/Dropbox/Winter 2015/MV Research/MvApp')
shiny::runApp('C:/Users/Alizee/Dropbox/Winter 2015/MV Research/MvApp')
shiny::runApp('C:/Users/Alizee/Dropbox/Winter 2015/MV Research/MvApp')
shiny::runApp('C:/Users/Alizee/Dropbox/Winter 2015/MV Research/MvApp')
shiny::runApp('C:/Users/Alizee/Dropbox/Winter 2015/MV Research/MvApp')
shiny::runApp('C:/Users/Alizee/Dropbox/Winter 2015/MV Research/MvApp')
shiny::runApp('C:/Users/Alizee/Dropbox/Winter 2015/MV Research/MvApp')
shiny::runApp('C:/Users/Alizee/Dropbox/Winter 2015/MV Research/MvApp')
shiny::runApp('C:/Users/Alizee/Dropbox/Winter 2015/MV Research/MvApp')
shiny::runApp('C:/Users/Alizee/Dropbox/Winter 2015/MV Research/MvApp')
shiny::runApp('C:/Users/Alizee/Dropbox/Winter 2015/MV Research/MvApp')
